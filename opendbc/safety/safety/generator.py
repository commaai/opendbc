#!/usr/bin/env python3
import os
import re
import glob
import subprocess
import jinja2
import itertools
import pprint

from functools import partial
from jinja2 import Environment, StrictUndefined


generator_path = os.path.dirname(os.path.realpath(__file__))
include_pattern = re.compile(r'CM_ "IMPORT (.*?)";\n')
generated_suffix = '_generated.dbc'

# Require every template param to be defined when rendering.
def StrictTemplate(str):
  return Environment(undefined=StrictUndefined).from_string(str)

def JinjaRenderer(template):
  return StrictTemplate(template).render

def PythonRenderer(template):
  def render(**kwargs):
    rx_checks = []
    ns = {
      'rx_checks': rx_checks,
      'add_rx_check': lambda check: rx_checks.append(check),
    }
    exec(template, ns, kwargs)
    return '\n'.join(rx_checks)
  return render

# Args:
#   condition_groups: list[list[condition: str]]
#   render_outcome: function()
EXPAND_CONDITIONS = StrictTemplate('''
{%- macro generate_conditions(levels, current_conditions) -%}
{%- if levels -%}
{%- set current_level = levels[0] -%}
{%- set remaining_levels = levels[1:] -%}
{%- for condition in current_level -%}
{%- set new_conditions = current_conditions.copy() -%}
{%- set _ = new_conditions.update({condition: True}) -%}
{%- for other in current_level -%}
    {%- if other != condition -%}
        {%- set _ = new_conditions.update({other: False}) -%}
    {%- endif -%}
{%- endfor %}
if ({{ condition }}) {
{{ generate_conditions(remaining_levels, new_conditions) | indent(2) }}
}
{%- endfor %}
else {
{%- set new_conditions = current_conditions.copy() -%}
{%- for condition in current_level -%}
    {%- set _ = new_conditions.update({condition: False}) -%}
{%- endfor -%}
{{ generate_conditions(remaining_levels, new_conditions) | indent(2) }}
}
{%- else %}
{{ render_outcome(current_conditions) }}
{%- endif -%}
{%- endmacro -%}

{{ generate_conditions(condition_groups, {}) | indent(2) }}
''')

def expand_conditions(condition_groups, render_outcome):
  with_comments = render_with_comments(render_outcome)
  return EXPAND_CONDITIONS.render(condition_groups=condition_groups,
                                  render_outcome=with_comments)

def render_with_comments(render):
  def wrapped(conditions):
    condition_str = "\n".join([f"// {k}: {v}" for k, v in conditions.items()])
    return f"{condition_str}\n" + render(**conditions)
  return wrapped

def _remove_empty_lines(text):
    return '\n'.join(line for line in text.splitlines() if line.strip())

# Generate C code to init a safety_config for any combination of conditions.
#
# Args:
# template: str
#   jinja template for generating a safety config based on conditions.
# condition_groups: list[list[condition: str]]
#   condition: an identifier of an existing boolean in C.
#     These identifiers will be available in the template.
#   list[condition]: mutually exclusive conditions.
#     A default, naked else case is included automatically
#     and does not need to be specified.
#     e.g. [["boat_canfd", "boat_doip"], ["boat_long"]]
def generate_safety_config(template, condition_groups,
                           renderer=JinjaRenderer):
  render = renderer(template)

  output = expand_conditions(condition_groups=condition_groups,
                             render_outcome=render)

  return _remove_empty_lines(output)


def generate_rx_checks(fn_name, condition_groups, template):
  generate_safety_config(template, condition_groups)


def generate_init_header(filename):
  output = ("// Generated by opendbc/safety/generator/generator.py\n\n" +
    "" # TODO: fn content
    )
  return output